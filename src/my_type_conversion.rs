// Rust是一门强类型语言，不支持隐形类型转换
// Rust为了实现类型转换有两种方式

use std::mem;

pub fn my_type_conversion() {
    println!("-------------type_conversion------------------");

    // 1.as语法
    // 最基础的一种类型转换 通常用于整数、浮点数、字符数据之间的转换
    let a: i8 = -10;
    let b = a as u8;
    println!("{}", b);
    // 相同类型大小的整形之间如i32->u32的转换仅仅是类型改一下是nop的
    // 大的整型转换为小的整型，如u32->u8会截断
    // 小的整型转换为大的整形
    // - 如果原类型是无符号，则会补0(zero-extend)
    // - 如果原类型是由符号，则会补符号(sign-extend)
    // 浮点数转换为整型会向0舍入
    // 整型转换为浮点数 会产生整型的浮点表示，如有必要会舍入（未指定舍入策略）
    // f32转换为f64是完美无缺的
    // f64转换f32会产生最接近的可能值（未指定舍入策略）

    // 2.transmute
    // 这是一个非常危险的工具
    // 除非你知道自己在干什么，如无必要不要去使用
    // as 是允许安全的类型转换，比如会拒绝将4个字节转换为u32
    let a = [0u8, 0u8, 0u8, 0u8];
    // let b = a as u32; // 不是安全的转换，会报错
    // 我们知道u32在内存中就是4个连续的u8，因此我们可以使用一种危险的方法，告诉编译器
    // 直接以另一种数据类型对待内存中的数据，编译器会无效条件信任，但是除非你自己知道
    // 在干什么，不然不推荐使用transmute，要使用transmute，需要将代码写入unsafe块中。

    unsafe {
        // let b = [0u8,1u8,0u8,0u8];
        // Rust使用的是小端字节序，数位的低位，存储在内存中的低位
        //               低                                                         高
        let b: [u8; 4] = [0/*00000000*/, 1/*10000000*/, 0/*00000000*/, 0/*00000000*/]; // 0b00000000000000000000000100000000
        let c: u32 = mem::transmute(b);
        println!("c = {}", c);
    }
}
